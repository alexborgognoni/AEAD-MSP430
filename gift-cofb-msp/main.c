#include <stdio.h>

#include "giftb128.h"

#include "key_schedule.h"

/*Round constants*/
unsigned char GIFT_RC[40] = {
  0x01,
  0x03,
  0x07,
  0x0F,
  0x1F,
  0x3E,
  0x3D,
  0x3B,
  0x37,
  0x2F,
  0x1E,
  0x3C,
  0x39,
  0x33,
  0x27,
  0x0E,
  0x1D,
  0x3A,
  0x35,
  0x2B,
  0x16,
  0x2C,
  0x18,
  0x30,
  0x21,
  0x02,
  0x05,
  0x0B,
  0x17,
  0x2E,
  0x1C,
  0x38,
  0x31,
  0x23,
  0x06,
  0x0D,
  0x1B,
  0x36,
  0x2D,
  0x1A
};

uint32_t rconst[40] = {
  0x10000008,
  0x80018000,
  0x54000002,
  0x01010181,
  0x8000001f,
  0x10888880,
  0x6001e000,
  0x51500002,
  0x03030180,
  0x8000002f,
  0x10088880,
  0x60016000,
  0x41500002,
  0x03030080,
  0x80000027,
  0x10008880,
  0x4001e000,
  0x11500002,
  0x03020180,
  0x8000002b,
  0x10080880,
  0x60014000,
  0x01400002,
  0x02020080,
  0x80000021,
  0x10000080,
  0x0001c000,
  0x51000002,
  0x03010180,
  0x8000002e,
  0x10088800,
  0x60012000,
  0x40500002,
  0x01030080,
  0x80000006,
  0x10008808,
  0xc001a000,
  0x14500002,
  0x01020181,
  0x8000001a
};

extern void gift128_perm_msp(uint32_t * S, uint16_t RK[][8]);

void print_state(u32 * S) {
  printf("S0 %08lx, S1 %08lx, S2 %08lx, S3 %08lx\n", S[0], S[1], S[2], S[3]);
}

uint32_t rowperm(uint32_t S, int B0_pos, int B1_pos, int B2_pos, int B3_pos) {
  uint32_t T = 0;
  int b;
  for (b = 0; b < 8; b++) {
    T |= ((S >> (4 * b + 0)) & 0x1) << (b + 8 * B0_pos);
    T |= ((S >> (4 * b + 1)) & 0x1) << (b + 8 * B1_pos);
    T |= ((S >> (4 * b + 2)) & 0x1) << (b + 8 * B2_pos);
    T |= ((S >> (4 * b + 3)) & 0x1) << (b + 8 * B3_pos);
  }
  return T;
}

void SubCells(uint32_t * S) {

  uint32_t T;

  S[1] ^= S[0] & S[2];
  S[0] ^= S[1] & S[3];
  S[2] ^= S[0] | S[1];
  S[3] ^= S[2];
  S[1] ^= S[3];
  S[3] ^= 0xffffffff;
  S[2] ^= S[0] & S[1];

  T = S[0];
  S[0] = S[3];
  S[3] = T;
}

void PermBits(uint32_t * S) {
  /*===PermBits===*/
  S[0] = rowperm(S[0], 0, 3, 2, 1);
  S[1] = rowperm(S[1], 1, 0, 3, 2);
  S[2] = rowperm(S[2], 2, 1, 0, 3);
  S[3] = rowperm(S[3], 3, 2, 1, 0);
}

void PermBits_C_unrolled(uint32_t * S) {
  uint32_t T = 0;

  //////////////////////
  //                  //
  //      S[0]        //
  //                  //
  //////////////////////

  // S0, b = 0
  T |= ((S[0] >> (0)) & 0x1) << (0);
  T |= ((S[0] >> (1)) & 0x1) << (24);
  T |= ((S[0] >> (2)) & 0x1) << (16);
  T |= ((S[0] >> (3)) & 0x1) << (8);

  // S0, b = 1
  T |= ((S[0] >> (4)) & 0x1) << (1);
  T |= ((S[0] >> (5)) & 0x1) << (25);
  T |= ((S[0] >> (6)) & 0x1) << (17);
  T |= ((S[0] >> (7)) & 0x1) << (9);

  // S0, b = 2
  T |= ((S[0] >> (8)) & 0x1) << (2);
  T |= ((S[0] >> (9)) & 0x1) << (26);
  T |= ((S[0] >> (10)) & 0x1) << (18);
  T |= ((S[0] >> (11)) & 0x1) << (10);

  // S0, b = 3
  T |= ((S[0] >> (12)) & 0x1) << (3);
  T |= ((S[0] >> (13)) & 0x1) << (27);
  T |= ((S[0] >> (14)) & 0x1) << (19);
  T |= ((S[0] >> (15)) & 0x1) << (11);

  // S0, b = 4
  T |= ((S[0] >> (16)) & 0x1) << (4);
  T |= ((S[0] >> (17)) & 0x1) << (28);
  T |= ((S[0] >> (18)) & 0x1) << (20);
  T |= ((S[0] >> (19)) & 0x1) << (12);

  // S0, b = 5
  T |= ((S[0] >> (20)) & 0x1) << (5);
  T |= ((S[0] >> (21)) & 0x1) << (29);
  T |= ((S[0] >> (22)) & 0x1) << (21);
  T |= ((S[0] >> (23)) & 0x1) << (13);

  // S0, b = 6
  T |= ((S[0] >> (24)) & 0x1) << (6);
  T |= ((S[0] >> (25)) & 0x1) << (30);
  T |= ((S[0] >> (26)) & 0x1) << (22);
  T |= ((S[0] >> (27)) & 0x1) << (14);

  // S0, b = 7
  T |= ((S[0] >> (28)) & 0x1) << (7);
  T |= ((S[0] >> (29)) & 0x1) << (31);
  T |= ((S[0] >> (30)) & 0x1) << (23);
  T |= ((S[0] >> (31)) & 0x1) << (15);

  S[0] = T;
  T = 0;

  //////////////////////
  //                  //
  //      S[1]        //
  //                  //
  //////////////////////

  // S1, b = 0
  T |= ((S[1] >> (0)) & 0x1) << (8);
  T |= ((S[1] >> (1)) & 0x1) << (0);
  T |= ((S[1] >> (2)) & 0x1) << (24);
  T |= ((S[1] >> (3)) & 0x1) << (16);

  // S1, b = 1
  T |= ((S[1] >> (4)) & 0x1) << (9);
  T |= ((S[1] >> (5)) & 0x1) << (1);
  T |= ((S[1] >> (6)) & 0x1) << (25);
  T |= ((S[1] >> (7)) & 0x1) << (17);

  // S1, b = 2
  T |= ((S[1] >> (8)) & 0x1) << (10);
  T |= ((S[1] >> (9)) & 0x1) << (2);
  T |= ((S[1] >> (10)) & 0x1) << (26);
  T |= ((S[1] >> (11)) & 0x1) << (18);

  // S1, b = 3
  T |= ((S[1] >> (12)) & 0x1) << (11);
  T |= ((S[1] >> (13)) & 0x1) << (3);
  T |= ((S[1] >> (14)) & 0x1) << (27);
  T |= ((S[1] >> (15)) & 0x1) << (19);

  // S1, b = 4
  T |= ((S[1] >> (16)) & 0x1) << (12);
  T |= ((S[1] >> (17)) & 0x1) << (4);
  T |= ((S[1] >> (18)) & 0x1) << (28);
  T |= ((S[1] >> (19)) & 0x1) << (20);

  // S1, b = 5
  T |= ((S[1] >> (20)) & 0x1) << (13);
  T |= ((S[1] >> (21)) & 0x1) << (5);
  T |= ((S[1] >> (22)) & 0x1) << (29);
  T |= ((S[1] >> (23)) & 0x1) << (21);

  // S1, b =0 6
  T |= ((S[1] >> (24)) & 0x1) << (14);
  T |= ((S[1] >> (25)) & 0x1) << (6);
  T |= ((S[1] >> (26)) & 0x1) << (30);
  T |= ((S[1] >> (27)) & 0x1) << (22);

  // S1, b = 7
  T |= ((S[1] >> (28)) & 0x1) << (15);
  T |= ((S[1] >> (29)) & 0x1) << (7);
  T |= ((S[1] >> (30)) & 0x1) << (31);
  T |= ((S[1] >> (31)) & 0x1) << (23);

  S[1] = T;
  T = 0;

  //////////////////////
  //                  //
  //      S[2]        //
  //                  //
  //////////////////////

  // S2, b = 0, 2103
  T |= ((S[2] >> (0)) & 0x1) << (16);
  T |= ((S[2] >> (1)) & 0x1) << (8);
  T |= ((S[2] >> (2)) & 0x1) << (0);
  T |= ((S[2] >> (3)) & 0x1) << (24);

  // S2, b = 1
  T |= ((S[2] >> (4)) & 0x1) << (17);
  T |= ((S[2] >> (5)) & 0x1) << (9);
  T |= ((S[2] >> (6)) & 0x1) << (1);
  T |= ((S[2] >> (7)) & 0x1) << (25);

  // S2, b = 2
  T |= ((S[2] >> (8)) & 0x1) << (18);
  T |= ((S[2] >> (9)) & 0x1) << (10);
  T |= ((S[2] >> (10)) & 0x1) << (2);
  T |= ((S[2] >> (11)) & 0x1) << (26);

  // S2, b = 3
  T |= ((S[2] >> (12)) & 0x1) << (19);
  T |= ((S[2] >> (13)) & 0x1) << (11);
  T |= ((S[2] >> (14)) & 0x1) << (3);
  T |= ((S[2] >> (15)) & 0x1) << (27);

  // S2, b = 4
  T |= ((S[2] >> (16)) & 0x1) << (20);
  T |= ((S[2] >> (17)) & 0x1) << (12);
  T |= ((S[2] >> (18)) & 0x1) << (4);
  T |= ((S[2] >> (19)) & 0x1) << (28);

  // S2, b = 5
  T |= ((S[2] >> (20)) & 0x1) << (21);
  T |= ((S[2] >> (21)) & 0x1) << (13);
  T |= ((S[2] >> (22)) & 0x1) << (5);
  T |= ((S[2] >> (23)) & 0x1) << (29);

  // S2, b = 6
  T |= ((S[2] >> (24)) & 0x1) << (22);
  T |= ((S[2] >> (25)) & 0x1) << (14);
  T |= ((S[2] >> (26)) & 0x1) << (6);
  T |= ((S[2] >> (27)) & 0x1) << (30);

  // S2, b = 7
  T |= ((S[2] >> (28)) & 0x1) << (23);
  T |= ((S[2] >> (29)) & 0x1) << (15);
  T |= ((S[2] >> (30)) & 0x1) << (7);
  T |= ((S[2] >> (31)) & 0x1) << (31);

  S[2] = T;
  T = 0;

  //////////////////////
  //                  //
  //      S[3]        //
  //                  //
  //////////////////////

  // S3, b = 0, 3210
  T |= ((S[3] >> (0)) & 0x1) << (24);
  T |= ((S[3] >> (1)) & 0x1) << (16);
  T |= ((S[3] >> (2)) & 0x1) << (8);
  T |= ((S[3] >> (3)) & 0x1) << (0);

  // S3, b = 1
  T |= ((S[3] >> (4)) & 0x1) << (25);
  T |= ((S[3] >> (5)) & 0x1) << (17);
  T |= ((S[3] >> (6)) & 0x1) << (9);
  T |= ((S[3] >> (7)) & 0x1) << (1);

  // S3, b = 2
  T |= ((S[3] >> (8)) & 0x1) << (26);
  T |= ((S[3] >> (9)) & 0x1) << (18);
  T |= ((S[3] >> (10)) & 0x1) << (10);
  T |= ((S[3] >> (11)) & 0x1) << (2);

  // S3, b = 3
  T |= ((S[3] >> (12)) & 0x1) << (27);
  T |= ((S[3] >> (13)) & 0x1) << (19);
  T |= ((S[3] >> (14)) & 0x1) << (11);
  T |= ((S[3] >> (15)) & 0x1) << (3);

  // S3, b = 4
  T |= ((S[3] >> (16)) & 0x1) << (28);
  T |= ((S[3] >> (17)) & 0x1) << (20);
  T |= ((S[3] >> (18)) & 0x1) << (12);
  T |= ((S[3] >> (19)) & 0x1) << (4);

  // S3, b = 5
  T |= ((S[3] >> (20)) & 0x1) << (29);
  T |= ((S[3] >> (21)) & 0x1) << (21);
  T |= ((S[3] >> (22)) & 0x1) << (13);
  T |= ((S[3] >> (23)) & 0x1) << (5);

  // S3, b = 6
  T |= ((S[3] >> (24)) & 0x1) << (30);
  T |= ((S[3] >> (25)) & 0x1) << (22);
  T |= ((S[3] >> (26)) & 0x1) << (14);
  T |= ((S[3] >> (27)) & 0x1) << (6);

  // S3, b = 7
  T |= ((S[3] >> (28)) & 0x1) << (31);
  T |= ((S[3] >> (29)) & 0x1) << (23);
  T |= ((S[3] >> (30)) & 0x1) << (15);
  T |= ((S[3] >> (31)) & 0x1) << (7);

  S[3] = T;
}

void AddRoundConstant(uint32_t * S, uint8_t RC) {
  S[3] ^= 0x80000000 ^ RC;
}

void AddRoundKey(uint32_t * S, uint16_t * W) {
  S[2] ^= ((uint32_t) W[2] << 16) | (uint32_t) W[3];
  S[1] ^= ((uint32_t) W[6] << 16) | (uint32_t) W[7];
}

void KeySchedule(uint16_t K[8], uint16_t RK[40][8]) {

  uint16_t T6, T7;

  for (unsigned int i = 0; i < 40; i++) {
    T6 = (K[6] >> 2) | (K[6] << 14);
    T7 = (K[7] >> 12) | (K[7] << 4);
    K[7] = K[5];
    K[6] = K[4];
    K[5] = K[3];
    K[4] = K[2];
    K[3] = K[1];
    K[2] = K[0];
    K[1] = T7;
    K[0] = T6;
    for (unsigned int j = 0; j < 8; j++) {
      RK[i][j] = K[j];
    }
  }
}

//void PrintRK(uint16_t RK[40][8]) {
//  for (unsigned int i = 0; i<40; i++) {
//    printf("\n\nIteration: %i\n", i+1);
//    for (unsigned int j = 0; j<8; j++) {
//      printf("%04" PRIx16, RK[i][j]);
//    }
//  }
//}

void test_state_update(void) {
  uint16_t K[8];
  uint16_t ki = 0x89ab;

  uint16_t RK[40][8];

  for (unsigned int i = 0; i < 8; i++) {
    K[i] = ki;
    ki = ki + 0x89ab;
  }

  //  printf("----------- Initial Key ----------\n");
  //  for (unsigned int j = 0; j<8; j++) {
  //    printf("%04" PRIx16, K[j]);
  //  }

  KeySchedule(K, RK);

  uint32_t S[4];
  uint32_t si = 0x48D159E0;

  for (unsigned int i = 0; i < 4; i++) {
    S[i] = si;
    si = si - 0x12345678;
  }

  printf("\n----------------- ORIGINAL STATE -----------------\n");

  print_state(S);

  printf("\n----------------- STATE C -----------------\n");

  for (unsigned int round = 0; round < 40; round++) {
    SubCells(S);
    PermBits(S);
    AddRoundConstant(S, GIFT_RC[round]);
    AddRoundKey(S, RK[round]);
  }

  print_state(S);

  printf("\n----------------- STATE MSP -----------------\n");

  si = 0x48D159E0;
  for (unsigned int i = 0; i < 4; i++) {
    S[i] = si;
    si = si - 0x12345678;
  }

  gift128_perm_msp(S, RK);

  print_state(S);
}

int main(void) {
  test_state_update();
  return 0;
}